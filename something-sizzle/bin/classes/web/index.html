<?xml version="1.0" encoding="UTF-8" ?>
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <title>TomP2P, a P2P-based key-value pair storage library</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" type="text/css" href="/design/W.layout.css+content.css,Mcc.YSMFr8SpMP.css.pagespeed.cf.6d7_m24pBU.css"/>
  
  <link rel="icon" type="image/png" href="../../design/favicon.png"/>
  <script src="/web/js/jquery.min.js"></script>
  <script src="/web/js/something.js"></script>
 </head>
 <body>
  <span id="bgimage"><img border="0" src="data:image/png;base64,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"></span>
  <!-- Banner -->
  <div class="banner">
   <h1><a href="/">Tom<span class="alt">P2P</span></a></h1>
   <h2><span class="alt">A P2P-based high performance key-value pair storage library</span></h2>
  </div>
  <div style="clear: both;"></div>
  <!-- Quick navigation (level0) for going further -->
  <div id="bar">
   <div id="qnav">
    <ul><li><a href="/">Home</a></li>
           <li><a href="/doc">Documentation</a></li>
           <li><a href="/news">News</a></li>
           <li><a href="/dev">Development</a></li>
           <li><a href="/community">Community</a></li>
           <li><a href="/downloads">Downloads</a></li>
     </ul>
   </div>
   <!-- Breadcrumb bar for going back -->
   <div id="breadcrumb">
    <ul><li><a href="/">/</a></li><li><a href="/doc/">Documentation</a></li><li><a href="/doc/quick/">Quick Introduction</a></li></ul>
   </div>
  </div>
  <!-- Detailed navigation level1-x for going further -->
    <!-- Content -->
  <div id="documents">
       <span id="documentEntry">
           <div id="info"><ul>
        <li id="filename"><a href="introduction_5.html">introduction_5</a></li>
             </ul></div>
         <div id="document"><div class="textile">
<h1 id="Introductionin5MinutesPutandGet">Introduction in 5 Minutes &#8211; Put and Get</h1><p>In order to create a P2P network with TomP2P, all peers need to:</p><ol><li>Create an identity</li><li>Listen for incoming connections</li><li>Bootstrap to a known peer in the P2P network</li><li>Start application specific communication</li></ol><p>In the following example, the application is a mapping service that maps a name to a value. So, first we create an identity, listen for incoming connections, and bootstrap to a well known peer in our constructor. The bootstrapping in this example is done via broadcasting, so both peers need to be reachable via layer 2. We assume that the well known peer listens on port 4001. The application can store and retrieve key and values. If you have 3 arguments in the main method, then a name and its value are stored, if you have 2 arguments, the key is queried. For simplicity, all operations are blocking.</p><pre class="java"><code>import java.io.IOException;
import net.tomp2p.futures.FutureDHT;
import net.tomp2p.futures.FutureBootstrap; 
import net.tomp2p.p2p.Peer;
import net.tomp2p.peers.Number160;
import net.tomp2p.storage.Data;
public class Example1 {
	final private Peer peer;
	public Example1(int nodeId) throws Exception {
		this.peer=new Peer(Number160.createHash(nodeId));
		this.peer.listen(4000+nodeId, 4000+nodeId);
		FutureBootstrap fb=this.peer.bootstrapBroadcast(4001);
		fb.awaitUninterruptibly();
		peer.discover(fb.getBootstrapTo().iterator().next()).awaitUninterruptibly();
	}
	public static void main(String[] args) throws NumberFormatException, Exception {
		Example1 dns=new Example1(Integer.parseInt(args[0]));
		if(args.length==3) {
			dns.store(args[1],args[2]);
		}
		if(args.length==2) {
			System.out.println("Name:"+args[1]+" IP:"+dns.get(args[1]));
		}
	}
	private String get(String name) throws ClassNotFoundException, IOException {
		FutureDHT futureDHT=peer.get(Number160.createHash(name));
		futureDHT.awaitUninterruptibly();
		if(futureDHT.isSuccess()) {
			return futureDHT.getData().values().iterator().next().getObject().toString();
		}
		return "not found";
	}
	private void store(String name, String ip) throws IOException {
		peer.put(Number160.createHash(name), new Data(ip)).awaitUninterruptibly();
	}
}
</code></pre><p>To run this example, you first have to start the well known peer on port 4001:</p><p><code>java Example1 1 test.ch 192.168.1.1</code></p><p>Then you can add as many other clients as you want:</p><p><code>java Example1 2 test.ch</code></p></div></div>
    </span>
    <div style="clear: both;"></div>
       <span id="documentEntry">
           <div id="info"><ul>
        <li id="filename"><a href="introduction_30.html">introduction_30</a></li>
             </ul></div>
         <div id="document"><div class="textile">
<h1 id="Introductionin30MinutesPutandGetExamplewithFutures">Introduction in 30 Minutes &#8211; Put and Get Example with Futures</h1><p>First, a peer with an ID has to be created. You can either set a random peer ID, or you can create the peer with a <code>KeyPair</code>, which takes a public key and generates the ID (SHA-1) out of this key. The example below shows the creating of a peer with a random ID.</p><pre class="java"><code>Random rnd = new Random();
Peer master = new Peer(new Number160(rnd));

</code></pre><p>Next the peer needs to start listening on a port, lets go with the port 4001.</p><pre class="java"><code>master.listen(4001, 4001);
</code></pre><p>Since its a P2P network, we need some more peers. You can either create a new peer and listen to another port, or you can attach a new peer to an existing port. The later is more resource friendly and many thousands of peers can be created.</p><pre class="java"><code>Peer another = new Peer(new Number160(rnd));
another.listen(master);

</code></pre><p>Before we bootstrap, we need to discover if our peer is behind a NAT and if TomP2P needs to configure NAT via UPNP</p><pre class="java"><code>FutureDiscover future = another.discover(master.getPeerAddress());
future.awaitUninterruptibly();

</code></pre><p>The next step in a P2P network is to bootstrap. Lets bootstrap <code>another</code> to <code>master</code>. For now we use <code>awaitUninterruptibly</code> to wait for the result. The future concept is explained in the next section.</p><pre class="java"><code>FutureBootstrap future = another.bootstrap(master.getPeerAddress());
future.awaitUninterruptibly();

</code></pre><p>In order to store data in TomP2P, the object needs to be wrapped with the <code>Data</code> class. The <code>data</code> class offers additional features, such as setting a TTL or signing the object. Then, <code>put</code> or <code>add</code> is called, which starts the routing process, finds the peers close to <code>nr</code>, where the data is stored.</p><pre class="java"><code>Data data = new Data("test");
Number160 nr = new Number160(rnd);
FutureDHT futureDHT = master.put(nr, data);
futureDHT.awaitUninterruptibly();

</code></pre><p>A proper shutdown is initiated by calling <code>shutdown()</code> from the master peer.</p><pre class="java"><code>master.shutdown();
</code></pre><h2 id="Futures">Futures</h2><p>Since TomP2P uses non-blocking communication, a future object is required to keep track of future results. Thus, a <code>get</code>, <code>put</code>, or <code>add</code> returns immediately and the future object is used to get the results from those operations. Most of the time the following code will not work as expected, since the <code>get</code> returns immediately:</p><pre class="java"><code>FutureDHT futureDHT = master.get(nr);
//you need to call futureDHT.awaitUninterruptibly() to get any data;
futureDHT.getData();

</code></pre><p>There are two options to get the data from the future object. The first is by blocking and waiting for the result to arrive, which can be either <code>await()</code> or <code>awaitUninterruptibly()</code>. The second option is to add a listener, which gets called whenever a result is ready. It is preferred to use this second option and avoid blocking, because in the worst case, you might cause a deadlock if <code>await()</code> is called from a wrong (I/O) thread. If such a listener is used, then the listeners gets called in <strong>all</strong> cases. If no peer replies, the timeout handler triggers the listener.</p><pre class="java"><code>futureDHT.addListener(new BaseFutureAdapter&lt;FutureDHT>()
{
 @Override
 public void operationComplete(FutureDHT future) throws Exception
 {
   if(future.isSuccess()) // this flag indicates if the future was successful
    System.out.println("success");
   else
    System.out.println("failure");
 }
});

</code></pre><p>Under the hood, TomP2P uses the future concept in many places, for example the routing process is entirely based on futures objects and listeners.</p></div></div>
    </span>
    <div style="clear: both;"></div>
       <span id="documentEntry">
           <div id="info"><ul>
        <li id="filename"><a href="introduction_net.html">introduction_net</a></li>
             </ul></div>
         <div id="document"><div class="textile">
<h1 id="IntroductionintogettingTomP2PworkontheInternet">Introduction into getting TomP2P work on the Internet</h1><p>Most of the examlpes run on the same host to make it easier to test them. Since TomP2P is meant to run on many hosts, the following examples show how to set up TomP2P on multiple hosts. These examples cover the setup of the peers, since the operations such as <code>put()</code> an <code>get()</code> do not change.</p><pre class="java"><code>Random r = new Random();
peer = new Peer(new Number160(r)); // create a peer with a random peerID
//peer.getP2PConfiguration().setBehindFirewall(true); //default is set to false
Bindings b = new Bindings();
b.addInterface("eth0");
peer.listen(4000, 4000, b);

</code></pre><p>This snippet creates a peer and listens on the interface <code>eth0</code>. If <code>b.addInterface("eth0");</code> is ommited, the peer listens to all interfaces. Lets assume this snippet runs on <code>host A</code> with IP address 192.168.1.10 and on <code>host B</code> with IP address 192.168.1.20, then the following snippet connects <code>host A</code> to <code>host B</code>. (The code snipped below works with 4.0.8-SNAPSHOT and higher)</p><pre class="java"><code>//discover of UPNP and NAT-PMP, needed if setBehindFirewall = true
//FutureDiscover fd = peer.discover(InetAddress.getByName("192.168.1.20"), 4000, 4000);
//fd.awaitUninterruptibly();
//
//to call peer.bootstrap(), you must know the peer ID. If the ID is not known, use InetSocketAddress.
InetSocketAddress inetSock = new InetSocketAddress(InetAddress.getByName("192.168.1.20"), 4000);
FutureBootstrap fb = peer.bootstrap(inetSock);
fb.awaitUninterruptibly();

</code></pre><p>For more information about <code>setBehindFirewall(true)</code>, please read UPNP NAT and Port Forwarding detection in the <a href="../advanced">advanced topics</a>.</p></div></div>
    </span>
    <div style="clear: both;"></div>
     </div>
  <!-- Footer -->
  <div class="footer"></div>
  </body>
</html>
